import sha256 from "../../node_modules/crypto-js/sha256"
import CryptoJS from "../../node_modules/crypto-js"
import bCrypt from "../encryption/bCrypt.js"
const builtin = require("../fetch/Common.js").default

export default class ApplicationInfo {

    #endpoints = {}
    #name
    #key
    #clientKey
    #package
    #version
    #mode
    #lock

    constructor(json) {
        const obj = JSON.parse(json)
        const app = obj.application
        this.#name = app.name
        this.#key = app.key
        this.#clientKey = app.client_key
        this.#package = app.pkg
        this.#version = app.version
        this.#mode = app.mode
        this.#endpoints = app.endpoints ?? {}
        this.createLock(JSON.stringify(app)).then((v) => { this.#lock = v; console.log(v); console.log("lockValidation=" + this.checkLock(JSON.stringify(app))) })

    }

    test(input) {
        //this.key is a public key... every browser the server sends it to is the same value
        //this.client_key is a browser unique (cookie) that is generated by the server
        //this.version is actually a signature test (not a string of 1.0.0.1 anymore) which ?? should stay the same across all browsers

        //to verify that nothing has been changed, and later to encrypt local storage
        //"locks" are created around this framework to force anyone attempting
        //to tamper with cookies and local storage or in memory functions
        //to look at how the server generates the client_key and version

        //this.key = rand(32).seed("v1.0.0.1")
        //this.client_key = getFromServer(hmac256(client.rand(32), this.key)
        //this.version = getFromServer(bcrypt(this.client_key + plus something else for the server to hide))

        //createLock(input)
        //let key = AES256.gcm(data: input, key: this.client_key, iv: hard coded value)
        //let lock = AES256.gcm(data: this.version, key: key, iv: same hard coded value)
        //return lock

        //checkLock(input, lock)
        //let key = AES256.gcm(data: input, key: this.client_key, iv: hard coded value)
        //let decryptedLock = AES256.decrypt(data: lock, key: key, iv: same hard coded value)
        //return bcrypt.matches(decryptedLock, this.version)

    }

    async createLock(input) {
        const cookie = builtin.getCookie("client_id")
        const client_key = this.#clientKey
        const key = CryptoJS.enc.Hex.parse(client_key)
        const hashKey = CryptoJS.enc.Hex.parse(cookie)
        console.log(sha256(input))
        const data = sha256(input)
        const lockKey = CryptoJS.AES.encrypt(data, key, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }).ciphertext.toString(CryptoJS.enc.Hex)
        const salt = bCrypt.getSalt(this.#version)
        const hash = await async function () {
            console.log("client_key=" + client_key)
            console.log("cookie_val=" + cookie)
            console.log("decrypted1=" + CryptoJS.AES.decrypt({ciphertext: key}, hashKey, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }))
            console.log("decrypted2=" + CryptoJS.AES.decrypt(client_key, hashKey, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }))
            const hash_value = CryptoJS.AES.decrypt({ciphertext: key}, hashKey, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }).toString(CryptoJS.enc.Hex)
            return await bCrypt.hash(hash_value, salt)
        }()
        const raw_hash = hash.padEnd(64, String.fromCharCode(28));
        console.log("raw_hash=" + raw_hash)
        console.log("last_char=" + raw_hash[53] + ", int=" + raw_hash.charCodeAt(53))
        console.log("lockKey=" + lockKey)
        const lk = CryptoJS.enc.Hex.parse(lockKey)
        console.log(this.string2Hex(raw_hash))
        return CryptoJS.AES.encrypt(raw_hash, lk, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }).ciphertext.toString(CryptoJS.enc.Hex)
    }

    string2Hex(tmp) {
        var str = '';
        for(var i = 0; i < tmp.length; i++) {
            str += tmp[i].charCodeAt(0).toString(16);
        }
        return str;
    }

    checkLock(input) {
        return bCrypt.verifyLock(input, () => { return this.#lock }, this.#clientKey, this.#lock)
    }

    endpoints() {
        return this.#endpoints
    }

    isDebug() {
        return true;
    }

    getClientKey() {
        return this.#clientKey;
    }

    getAppKey() {
        return this.#key
    }

}